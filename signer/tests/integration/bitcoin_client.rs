use bitcoin::{absolute::LockTime, hashes::Hash as _, transaction::Version, BlockHash, Network};
use bitcoincore_rpc::{json::AddressType, RpcApi as _};
use sbtc::rpc::BitcoinCoreClient;
use signer::{bitcoin::BitcoinInteract, util::ApiFallbackClient};
use url::Url;

#[tokio::test]
async fn test_get_block_not_found() {
    let url: Url = "http://devnet:devnet@localhost:18443".parse().unwrap();
    let client = BitcoinCoreClient::try_from(url).unwrap();
    let result = client.inner_client().get_block(&BlockHash::all_zeros());

    // This will return: JsonRpc(Rpc(RpcError { code: -5, message: "Block not found", data: None }))
    assert!(matches!(
        result.unwrap_err(),
        bitcoincore_rpc::Error::JsonRpc(bitcoincore_rpc::jsonrpc::Error::Rpc(rpc_error))
            if rpc_error.code == -5
    ))
}

// TODO: Figure out how to let this (and similar tests) run against the wallet
// generated by `initialize_blockchain()`. See comment in the test below.
#[ignore = "This test needs to be run against a 'fresh' bitcoin core instance"]
#[tokio::test]
async fn test_get_block_works() {
    let url: Url = "http://devnet:devnet@localhost:18443".parse().unwrap();
    let client = BitcoinCoreClient::try_from(url.clone()).unwrap();

    let wallets = client.inner_client().list_wallets().unwrap();
    if !wallets.contains(&"default".to_string()) {
        client
            .inner_client()
            .create_wallet("default", None, None, None, None)
            .unwrap();
    }

    // Tried using this but the wallet it creates doesn't have any keys (and
    // private keys are disabled), so we can't import keys or generate addresses.
    // It looks like we'd either need to rethink that or use a separate bitcoind
    // instance for "write" tests. Ideally we could just use a separate wallet,
    // but it doesn't seem that this client supports setting the current wallet
    // to use in requests.
    //
    // This works for now since we can at least validate that the function works
    // as expected, but it would be ideal if it could run as a standard part of
    // the integration test suite.
    //
    // let (_, _) = initialize_blockchain();

    let address = client
        .inner_client()
        .get_new_address(None, Some(AddressType::Legacy))
        .unwrap()
        .require_network(Network::Regtest)
        .unwrap();
    let blocks = client
        .inner_client()
        .generate_to_address(5, &address)
        .unwrap();

    let client = ApiFallbackClient::<BitcoinCoreClient>::try_from([url].as_slice()).unwrap();

    // Double-check that an all-zero block doesn't return an error or something else unexpected.
    let block = client.get_block(&BlockHash::all_zeros()).await;
    assert!(block.is_ok_and(|x| x.is_none()));

    for block in blocks.iter() {
        let b = client
            .get_block(block)
            .await
            .expect("failed to get block")
            .expect("expected to receive a block, not None");

        assert_eq!(b.header.block_hash(), *block);
    }
}

// TODO: Complete this test with inputs/outputs (it currently fails as the
// transaction is invalid). I didn't do this for now as it takes time, but I
// wanted to get a skeleton in place.
#[ignore = "This test needs to be completed (i.e. with inputs/outputs"]
#[tokio::test]
async fn broadcast_tx_works() {
    let url: Url = "http://devnet:devnet@localhost:18443".parse().unwrap();
    let client = ApiFallbackClient::<BitcoinCoreClient>::try_from([url].as_slice()).unwrap();

    let tx = bitcoin::Transaction {
        version: Version::TWO,
        lock_time: LockTime::ZERO,
        input: vec![],
        output: vec![],
    };

    client.broadcast_transaction(&tx).await.unwrap();
}
