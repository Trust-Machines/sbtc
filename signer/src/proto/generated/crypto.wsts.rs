// This file is @generated by prost-build.
/// Scalar maps to a wrapper around libsecp256k1's internal secp256k1_scalar
/// struct. It's a number between 0 and the order of the secp256k1 curve.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Scalar {
    #[prost(message, optional, tag = "1")]
    pub value: ::core::option::Option<super::Uint256>,
}
/// Represents a point on the secp256k1 elliptic curve. A Point is either a
/// public key, like the crypto.PublicKey type, or the point at infinity.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Point {
    /// The x-coordinate of the point.
    #[prost(message, optional, tag = "1")]
    pub x_coordinate: ::core::option::Option<super::Uint256>,
    /// Represents the parity bit of the point. True means the parity is
    /// odd, while false means the parity is even.
    #[prost(bool, tag = "2")]
    pub parity_is_odd: bool,
}
/// DKG begin message from coordinator to signers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgBegin {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
}
/// DKG public shares message from signer to all signers and coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgPublicShares {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "2")]
    pub signer_id: u32,
    /// List of (party_id, commitment)
    #[prost(message, repeated, tag = "3")]
    pub commitments: ::prost::alloc::vec::Vec<PartyCommitment>,
}
/// The public polynomial committed to by one of the party members who are
/// participating in distributed key generation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartyCommitment {
    /// The specific party that submitted the public polynomial.
    #[prost(uint32, tag = "1")]
    pub party_id: u32,
    /// The public polynomial of the associated party. Each polynomial
    /// includes a proof of ownership of the underlying private privte
    /// polynomial.
    #[prost(message, optional, tag = "2")]
    pub commitment: ::core::option::Option<PolyCommitment>,
}
/// DKG private begin message from signer to all signers and coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgPrivateBegin {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "2")]
    pub signer_ids: ::prost::alloc::vec::Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "3")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
}
/// DKG private shares message from signer to all signers and coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgPrivateShares {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "2")]
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    #[prost(message, repeated, tag = "3")]
    pub shares: ::prost::alloc::vec::Vec<PrivateShare>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateShare {
    #[prost(uint32, tag = "1")]
    pub source_party_id: u32,
    /// The encrypted private shares to send to the the other parties.
    #[prost(message, repeated, tag = "2")]
    pub encrypted_shares: ::prost::alloc::vec::Vec<SecretShare>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretShare {
    #[prost(uint32, tag = "1")]
    pub signer_id: u32,
    /// This is the private polynomial evaluated at the `signer_id` and then
    /// encrypted in such a way that only the public key associated with the
    /// above `signer_id` can decrypt it.
    #[prost(bytes = "vec", tag = "2")]
    pub encrypted_secret_share: ::prost::alloc::vec::Vec<u8>,
}
/// DKG end begin message from signer to all signers and coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgEndBegin {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "2")]
    pub signer_ids: ::prost::alloc::vec::Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "3")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
}
/// DKG end message from signers to coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgEnd {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer ID
    ///
    /// DKG status for this Signer after receiving public/private shares
    /// pub status: DkgStatus,
    #[prost(uint32, tag = "2")]
    pub signer_id: u32,
}
/// Nonce request message from coordinator to signers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NonceRequest {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// The message to sign
    #[prost(bytes = "vec", tag = "4")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    /// Whether to make a taproot signature
    #[prost(bool, tag = "5")]
    pub is_taproot: bool,
    /// Taproot merkle root. This field is optional
    #[prost(message, optional, tag = "6")]
    pub merkle_root: ::core::option::Option<MerkleRoot>,
}
/// Nonce response message from signers to coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NonceResponse {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "4")]
    pub signer_id: u32,
    /// Key IDs
    #[prost(uint32, repeated, tag = "5")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
    /// Public nonces
    #[prost(message, repeated, tag = "6")]
    pub nonces: ::prost::alloc::vec::Vec<PublicNonce>,
    /// Bytes being signed
    #[prost(bytes = "vec", tag = "7")]
    pub message: ::prost::alloc::vec::Vec<u8>,
}
/// Signature share request message from coordinator to signers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureShareRequest {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// Nonces responses used for this signature
    #[prost(message, repeated, tag = "4")]
    pub nonce_responses: ::prost::alloc::vec::Vec<NonceResponse>,
    /// Bytes to sign
    #[prost(bytes = "vec", tag = "5")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    /// Whether to make a taproot signature
    #[prost(bool, tag = "6")]
    pub is_taproot: bool,
    /// Taproot merkle root. This field is optional
    #[prost(message, optional, tag = "7")]
    pub merkle_root: ::core::option::Option<MerkleRoot>,
}
/// Signature share response message from signers to coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureShareResponse {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "4")]
    pub signer_id: u32,
    /// Signature shares from this Signer
    #[prost(message, repeated, tag = "5")]
    pub signature_shares: ::prost::alloc::vec::Vec<SignatureShare>,
}
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ProofIdentifier>,
    /// The public polynomial which commits to the secret polynomial
    #[prost(message, repeated, tag = "2")]
    pub poly: ::prost::alloc::vec::Vec<Point>,
}
/// This type maps to the `ID` type in WSTS, which encapsulates the ID and a
/// Schnorr proof of ownership of the polynomial.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofIdentifier {
    /// The ID
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Scalar>,
    /// The public schnorr response, kG
    #[prost(message, optional, tag = "2")]
    pub schnorr_response: ::core::option::Option<Point>,
    /// The aggregate of the schnorr committed values, kca
    #[prost(message, optional, tag = "3")]
    pub aggregate_commitment: ::core::option::Option<Scalar>,
}
/// A bad private share
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadPrivateShare {
    /// The DH shared key between these participants
    #[prost(message, optional, tag = "1")]
    pub shared_key: ::core::option::Option<Point>,
    /// Proof that the shared key is a valid DH tuple as per Chaum-Pedersen.
    #[prost(message, optional, tag = "2")]
    pub tuple_proof: ::core::option::Option<TupleProof>,
}
/// A Chaum-Pedersen proof that (G, A=a*G, B=b*G, K=(a*b)*G) is a
/// Diffie-Hellman tuple.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TupleProof {
    /// R = r*G for a random scalar r
    #[prost(message, optional, tag = "1")]
    pub random_commitment: ::core::option::Option<Point>,
    /// rB = r*B
    #[prost(message, optional, tag = "2")]
    pub response: ::core::option::Option<Point>,
    /// z = r + a*s where s = H(G,A,B,K,R) as per Fiat-Shamir
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<Scalar>,
}
/// A merkle root is a 256 bit hash
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerkleRoot {
    /// The root of the merkle tree
    #[prost(message, optional, tag = "1")]
    pub root: ::core::option::Option<super::Uint256>,
}
/// A commitment to the private nonce
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicNonce {
    /// A commitment to the private nonce's first value
    #[prost(message, optional, tag = "1")]
    pub nonce_d: ::core::option::Option<Point>,
    /// A commitment to the private nonce's second value
    #[prost(message, optional, tag = "2")]
    pub nonce_e: ::core::option::Option<Point>,
}
/// A share of the party signature with related values
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureShare {
    /// The ID of the party
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// The party signature, z_i
    #[prost(message, optional, tag = "2")]
    pub signature_share: ::core::option::Option<Scalar>,
    /// The key IDs of the party
    #[prost(uint32, repeated, tag = "3")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
}
