// This file is @generated by prost-build.
/// Scalar maps to a number between 0 and the order of the secp256k1 curve.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Scalar {
    #[prost(message, optional, tag = "1")]
    pub value: ::core::option::Option<super::Uint256>,
}
/// Represents a point on the secp256k1 elliptic curve. A Point is either a
/// public key, like the crypto.PublicKey type, or the point at infinity.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Point {
    /// The x-coordinate of the point.
    #[prost(message, optional, tag = "1")]
    pub x_coordinate: ::core::option::Option<super::Uint256>,
    /// Represents the parity bit of the point. True means the parity is
    /// odd, while false means the parity is even.
    #[prost(bool, tag = "2")]
    pub parity_is_odd: bool,
}
/// DKG begin message from coordinator to signers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgBegin {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
}
/// DKG public shares message from signer to all signers and coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgPublicShares {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "2")]
    pub signer_id: u32,
    /// List of (signer_id, commitment)
    #[prost(message, repeated, tag = "3")]
    pub commitments: ::prost::alloc::vec::Vec<PartyCommitment>,
}
/// The public polynomial committed to by one of the party members who are
/// participating in distributed key generation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartyCommitment {
    /// The specific party that submitted the public polynomial.
    #[prost(uint32, tag = "1")]
    pub signer_id: u32,
    /// The public polynomial of the associated party. Each polynomial
    /// includes a proof of ownership of the underlying private private
    /// polynomial.
    #[prost(message, optional, tag = "2")]
    pub commitment: ::core::option::Option<PolyCommitment>,
}
/// DKG private begin message from signer to all signers and coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgPrivateBegin {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "2")]
    pub signer_ids: ::prost::alloc::vec::Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "3")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
}
/// DKG private shares message from signer to all signers and coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgPrivateShares {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "2")]
    pub signer_id: u32,
    /// List of (src_signer_id, Map(dst_key_id, encrypted_share))
    #[prost(message, repeated, tag = "3")]
    pub shares: ::prost::alloc::vec::Vec<PrivateShare>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateShare {
    /// The ID of the signer that created the secret share.
    #[prost(uint32, tag = "1")]
    pub source_signer_id: u32,
    /// The encrypted private shares to send to the the other parties.
    #[prost(message, repeated, tag = "2")]
    pub encrypted_shares: ::prost::alloc::vec::Vec<SecretShare>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretShare {
    /// The signer ID associated with the secret share. This is the only
    /// signer who will be able to decrypt the encrypted_secret_share field.
    #[prost(uint32, tag = "1")]
    pub signer_id: u32,
    /// This is the private polynomial evaluated at the `signer_id` and then
    /// encrypted in such a way that only the public key associated with the
    /// above `signer_id` can decrypt it.
    #[prost(bytes = "vec", tag = "2")]
    pub encrypted_secret_share: ::prost::alloc::vec::Vec<u8>,
}
/// DKG end begin message from signer to all signers and coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgEndBegin {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "2")]
    pub signer_ids: ::prost::alloc::vec::Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    #[prost(uint32, repeated, tag = "3")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
}
/// DKG end message from signers to coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgEnd {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "2")]
    pub signer_id: u32,
    /// DKG status for this Signer after receiving public/private shares
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<DkgStatus>,
}
/// Nonce request message from coordinator to signers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NonceRequest {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// The message to sign
    #[prost(message, optional, tag = "4")]
    pub message: ::core::option::Option<super::Uint256>,
    /// Whether to make a taproot signature
    #[prost(bool, tag = "5")]
    pub is_taproot: bool,
    /// Taproot merkle root. This field is optional
    #[prost(message, optional, tag = "6")]
    pub merkle_root: ::core::option::Option<MerkleRoot>,
}
/// Nonce response message from signers to coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NonceResponse {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "4")]
    pub signer_id: u32,
    /// Key IDs
    #[prost(uint32, repeated, tag = "5")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
    /// Public nonces
    #[prost(message, repeated, tag = "6")]
    pub nonces: ::prost::alloc::vec::Vec<PublicNonce>,
    /// Bytes being signed.
    #[prost(message, optional, tag = "7")]
    pub message: ::core::option::Option<super::Uint256>,
}
/// Signature share request message from coordinator to signers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureShareRequest {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// Nonces responses used for this signature
    #[prost(message, repeated, tag = "4")]
    pub nonce_responses: ::prost::alloc::vec::Vec<NonceResponse>,
    /// Bytes to sign.
    #[prost(message, optional, tag = "5")]
    pub message: ::core::option::Option<super::Uint256>,
    /// Whether to make a taproot signature
    #[prost(bool, tag = "6")]
    pub is_taproot: bool,
    /// Taproot merkle root. This field is optional
    #[prost(message, optional, tag = "7")]
    pub merkle_root: ::core::option::Option<MerkleRoot>,
}
/// Signature share response message from signers to coordinator
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureShareResponse {
    /// DKG round ID
    #[prost(uint64, tag = "1")]
    pub dkg_id: u64,
    /// Signing round ID
    #[prost(uint64, tag = "2")]
    pub sign_id: u64,
    /// Signing round iteration ID
    #[prost(uint64, tag = "3")]
    pub sign_iter_id: u64,
    /// Signer ID
    #[prost(uint32, tag = "4")]
    pub signer_id: u32,
    /// Signature shares from this Signer
    #[prost(message, repeated, tag = "5")]
    pub signature_shares: ::prost::alloc::vec::Vec<SignatureShare>,
}
/// A commitment to a polynomial, with a Schnorr proof of ownership bound to the ID
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolyCommitment {
    /// The party ID with a Schnorr proof
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ProofIdentifier>,
    /// The public polynomial which commits to the secret polynomial
    #[prost(message, repeated, tag = "2")]
    pub poly: ::prost::alloc::vec::Vec<Point>,
}
/// This type maps to the `ID` type in WSTS, which encapsulates the ID and a
/// Schnorr proof of ownership of the polynomial.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofIdentifier {
    /// The ID
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Scalar>,
    /// The public Schnorr response, kG
    #[prost(message, optional, tag = "2")]
    pub schnorr_response: ::core::option::Option<Point>,
    /// The aggregate of the Schnorr committed values, kca
    #[prost(message, optional, tag = "3")]
    pub aggregate_commitment: ::core::option::Option<Scalar>,
}
/// Final DKG status after receiving public and private shares
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DkgStatus {
    #[prost(oneof = "dkg_status::Mode", tags = "1, 2, 3, 4, 5, 6")]
    pub mode: ::core::option::Option<dkg_status::Mode>,
}
/// Nested message and enum types in `DkgStatus`.
pub mod dkg_status {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        /// DKG completed successfully
        #[prost(message, tag = "1")]
        Success(super::Success),
        /// Signer was in the wrong internal state to complete DKG
        #[prost(message, tag = "2")]
        BadState(super::BadState),
        /// DKG public shares were missing from these signer_ids
        #[prost(message, tag = "3")]
        MissingPublicShares(super::MissingPublicShares),
        /// DKG public shares were bad from these signer_ids
        #[prost(message, tag = "4")]
        BadPublicShares(super::BadPublicShares),
        /// DKG private shares were missing from these signer_ids
        #[prost(message, tag = "5")]
        MissingPrivateShares(super::MissingPrivateShares),
        /// DKG private shares were bad from these signer_ids
        #[prost(message, tag = "6")]
        BadPrivateShares(super::BadPrivateShares),
    }
}
/// DKG completed successfully
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Success {}
/// Signer was in the wrong internal state to complete DKG
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadState {}
/// DKG public shares were bad from these signer_ids.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MissingPublicShares {
    /// In WSTS this is a HashSet<u32>, so these should be unique, duplicates
    /// will be ignored at the application level.
    #[prost(uint32, repeated, tag = "1")]
    pub signer_ids: ::prost::alloc::vec::Vec<u32>,
}
/// DKG public shares were bad from these signer_ids.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadPublicShares {
    /// In WSTS this is a HashSet<u32>, so these should be unique, duplicates
    /// will be ignored at the application level.
    #[prost(uint32, repeated, tag = "1")]
    pub signer_ids: ::prost::alloc::vec::Vec<u32>,
}
/// DKG private shares were missing from these signer_ids.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MissingPrivateShares {
    /// In WSTS this is a HashSet<u32>, so these should be unique, duplicates
    /// will be ignored at the application level.
    #[prost(uint32, repeated, tag = "1")]
    pub signer_ids: ::prost::alloc::vec::Vec<u32>,
}
/// DKG private shares were bad from these signer_ids.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadPrivateShares {
    #[prost(map = "uint32, message", tag = "1")]
    pub shares: ::std::collections::HashMap<u32, BadPrivateShare>,
}
/// A bad private share
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadPrivateShare {
    /// The DH shared key between these participants
    #[prost(message, optional, tag = "1")]
    pub shared_key: ::core::option::Option<Point>,
    /// Proof that the shared key is a valid DH tuple as per Chaum-Pedersen.
    #[prost(message, optional, tag = "2")]
    pub tuple_proof: ::core::option::Option<TupleProof>,
}
/// A Chaum-Pedersen proof that (G, A=a*G, B=b*G, K=(a*b)*G) is a
/// Diffie-Hellman tuple.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TupleProof {
    /// This is a commitment to both the random commitment in the Schnorr
    /// proof and the private key used for the signature. It represents r*B.
    #[prost(message, optional, tag = "1")]
    pub combined_commitment: ::core::option::Option<Point>,
    /// The Schnorr proof using the commitment of the above Point.
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<SchnorrSignature>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchnorrSignature {
    /// This is R, where R = r*G for a random scalar r.
    #[prost(message, optional, tag = "1")]
    pub random_commitment: ::core::option::Option<Point>,
    /// This is z, where z = r + a*s where s = H(G,A,B,K,R) as per Fiat-Shamir
    #[prost(message, optional, tag = "2")]
    pub response: ::core::option::Option<Scalar>,
}
/// A merkle root is a 256 bit hash
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerkleRoot {
    /// The root of the merkle tree
    #[prost(message, optional, tag = "1")]
    pub root: ::core::option::Option<super::Uint256>,
}
/// A commitment to the private nonce
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicNonce {
    /// A commitment to the private nonce's first value
    #[prost(message, optional, tag = "1")]
    pub nonce_d: ::core::option::Option<Point>,
    /// A commitment to the private nonce's second value
    #[prost(message, optional, tag = "2")]
    pub nonce_e: ::core::option::Option<Point>,
}
/// A share of the party signature with related values
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureShare {
    /// The ID of the party
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// The party signature, z_i
    #[prost(message, optional, tag = "2")]
    pub signature_share: ::core::option::Option<Scalar>,
    /// The key IDs of the party
    #[prost(uint32, repeated, tag = "3")]
    pub key_ids: ::prost::alloc::vec::Vec<u32>,
}
